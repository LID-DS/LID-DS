import argparse
import random
import sys
import time

import requests
import numpy as np

from selenium import webdriver
from selenium.webdriver.chrome.options import Options

from pyvirtualdisplay import Display

def do_admin_browsing(victim_url, browser):
    """
    main loop of random browsing normal admin behaviour
    """
    admin_url = victim_url + '/admin'

    print("acting as admin")

    first_call = True
    steps = 0
    while True:
        try:
            sys.stdin.readline()
            steps += 1
            print("at step: " + str(steps))
            if first_call:
                # log in with admin credentials
                browser.get(admin_url)
                username_form = browser.find_elements_by_xpath('//*[@id="userid"]')[0]
                password_form = browser.find_elements_by_xpath('//*[@id="pwd"]')[0]
                login_button = browser.find_elements_by_xpath('/html/body/div[2]/div[1]/div/div/form/p[3]/input')[0]


                username_form.send_keys('admin')
                password_form.send_keys('eaRSfT')

                login_button.click()

                first_call = False

                print("logged in as admin")

            else:
                # then follow random links in backend
                print("follow link...")
                follow_link(victim_url, browser)

        except Exception as e:
            print(e)
            time.sleep(2)


def do_user_browsing(victim_url, browser):
    """
    main loop of random browsing normal user behaviour
    """

    print("acting as user")

    first_call = True
    steps = 0
    while True:
        try:
            # start the "normal routine"
            sys.stdin.readline()
            steps += 1
            print("at step: " + str(steps))
            if first_call:
                print("first call")
                browser.get(victim_url)
                print("opened victim at: " + victim_url)
                first_call = False
            else:
                print("follow link...")
                follow_link(victim_url, browser)

        except Exception as e:
            print("Exception occurred")
            print(e)
            time.sleep(2)


def follow_link(victim_url, browser):
    """
    iterates all "internal" links and chooses a random one to follow
    """
    # list all available local links
    link_list = list()
    for link in browser.find_elements_by_xpath('.//a'):
        link_url = link.get_attribute('href')
        if link_url:
            # check if url is not leading to other website, is visible and does not lead to same page eg: http://{url}/#
            if victim_url in link_url \
                    and link.is_displayed() \
                    and len(link_url) > len(victim_url) + 2 \
                    and 'logout' not in link_url:
                link_list.append(link)

    # check if surfer is in dead end, if so go to main page
    if not len(link_list) == 0:
        # randomly select one link to follow
        i = np.random.randint(0, high=len(link_list))
        selected_link = link_list[i]
        print('selected: [{}] of {} links'.format(i + 1, len(link_list)))
        print('clicking on: {}'.format(selected_link.get_attribute('href')))

        # handle non clickable elements
        try:
            selected_link.click()
        except:
            print("element was not clickable, going back to: " + victim_url)
            browser.get(victim_url)

        # handle alerts
        try:
            browser.switch_to.alert.accept()
            print("accepted alert")
        except:
            pass

    else:
        print("dead end, restart at: " + victim_url)
        browser.get(victim_url)



if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='HTTPS-Client Simulation.')

    parser.add_argument('-ip', dest='server_ip', action='store', type=str, required=True,
                        help='The IP address of the target server')
    parser.add_argument('-v', dest='verbose', action='store', type=bool, required=False, default=False,
                        help='Make the operations more talkative')

    args = parser.parse_args()

    # Disable requests warnings (caused by self signed server certificate)
    requests.packages.urllib3.disable_warnings()

    # Virtual display to run chrome-browser
    display = Display(visible=0, size=(800, 800))
    display.start()

    # Headless chrome-browser settings
    chrome_options = Options()
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument('--ignore-certificate-errors')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_browser = webdriver.Chrome(chrome_options=chrome_options)

    url = 'http://' + args.server_ip

    # start random surfer
    # 10% of surfers act as admin
    i = random.randint(0, 100)
    if i <= 10:
        do_admin_browsing(url, chrome_browser)
    else:
        do_user_browsing(url, chrome_browser)
