import argparse
import os
import random
import sys
import tempfile
import time

import requests
from pyvirtualdisplay import Display
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import webbrowser

from heartbeat import Heartbeat


def vprint(string):
    """
    prints the given string if the verbose flag is set
    """
    if args.verbose:
        print(string)


def in_range(value, min_max):
    return min_max[0] <= value <= min_max[1]


def https_requests(post_user, post_password):
    """
    main loop for normal behaviour
    """
    hb = Heartbeat(args.server_ip, 443, True)

    while True:
        try:
            sys.stdin.readline()
            random_choice = random.randint(1, 100)

            if in_range(random_choice, post_probability):
                vprint("do post")
                do_post(post_user, post_password)
            elif in_range(random_choice, get_probability):
                vprint("do get")
                do_get()
            elif in_range(random_choice, heartbeat_probability):
                vprint(" ".join(["Heartbeat:", username, "-->", args.server_ip]))
                hb.do_heartbeat()
        # handling victim shutdown before own shutdown
        except Exception as e:
            vprint(e)
            time.sleep(5)


def do_post(post_user, post_password):
    """
    executes POST request to victim
    """
    url = ''.join(['https://', args.server_ip, '/private/upload.php'])

    x = random.randrange(1, 100)
    if x <= prob_invalid_login:
        post_password = "wrong-password-123"

    # Create a random tempfile and upload it
    file_size = random.randint(1000, 10000)
    file = tempfile.NamedTemporaryFile(mode='w+b')
    file.write(os.urandom(file_size))

    # Send POST request to the server
    session = requests.Session()
    session.auth = (post_user, post_password)
    payload = {'press': 'OK'}
    files = {'userfile': open(file.name, 'rb')}
    session.post(url, files=files, data=payload, verify=False)
    vprint(' '.join(['POST:', 'user', post_user, 'file', file.name]))
    file.close()


def do_get():
    """
    executes GET request to victim
    """
    url = ''.join(['https://', args.server_ip, '/', random.choice(server_paths)])
    webbrowser.open(url)
    # driver.get(url)
    vprint(' '.join(['GET:', url]))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='HTTPS-Client Simulation.')

    parser.add_argument('-ip',
                        dest='server_ip',
                        action='store',
                        type=str,
                        required=True,
                        help='The IP address of the target server')
    parser.add_argument('-v',
                        dest='verbose',
                        action='store',
                        type=bool,
                        required=False,
                        default=False,
                        help='Make the operations more talkative')

    args = parser.parse_args()

    server_paths = ['index.html',
                    'work.html',
                    'about.html',
                    'blog.html',
                    'services.html',
                    'shop.html']

    # same users as in victims 'create_users.sh'
    users = {
        "user1": "password1",
        "user2": "password2",
        "user3": "password3",
        "user4": "password4",
        "user5": "password5",
        "user6": "password6",
        "user7": "password7",
        "user8": "password8",
        "user9": "password9",
        "user10": "password10"
    }

    # Disable requests warnings (caused by self signed server certificate)
    requests.packages.urllib3.disable_warnings()

    # Virtual display to run chrome-browser
    #display = Display(visible=0, size=(800, 800))
    #display.start()

    # Headless chrome-browser settings
    #chrome_options = Options()
    #chrome_options.add_argument("--no-sandbox")
    #chrome_options.add_argument('--ignore-certificate-errors')
    #driver = webdriver.Chrome(chrome_options=chrome_options)

    # probabilities
    post_probability = [1, 30]
    get_probability = [31, 80]
    heartbeat_probability = [81, 100]

    # Probability of invalid logins within the POST path
    prob_invalid_login = 5

    # pick random user
    user_list = list(users.keys())
    username = random.choice(user_list)
    password = users[username]

    https_requests(username, password)
